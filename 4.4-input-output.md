*[К оглавлению](index.md)*
# Ввод и вывод

1. [STDIN](#stdin)
2. [STDOUT](#stdout)
3. [STDERR](#stderr)
4. [Перенаправление потока ошибок](#перенаправление-потока-ошибок)
5. [Перенаправление потоков ошибок и вывода](#перенаправление-потоков-ошибок-и-вывода)
6. [Перенаправление вывода в скриптах](#перенаправление-вывода-в-скриптах)
7. [Временное перенаправление вывода](#временное-перенаправление-вывода)
8. [Постоянное перенаправление вывода](#постоянное-перенаправление-вывода)
9. [Перенаправление ввода в скриптах](#перенаправление-ввода-в-скриптах)
10. [Создание собственного перенаправления вывода](#создание-собственного-перенаправления-вывода)
11. [Создание дескрипторов файлов для ввода данных](#создание-дескрипторов-файлов-для-ввода-данных)
12. [Закрытие дескрипторов файлов](#закрытие-дескрипторов-файлов)
13. [Получение сведений об открытых дескрипторах](#получение-сведений-об-открытых-дескрипторах)
14. [Подавление вывода](#подавление-вывода)

```
Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2.

0, STDIN — стандартный поток ввода.
1, STDOUT — стандартный поток вывода.
2, STDERR — стандартный поток ошибок.
```

# STDIN
```
STDIN — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура. Когда в сценариях используют символ перенаправления ввода — <, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.
```

# STDOUT
```
STDOUT — стандартный поток вывода оболочки. По умолчанию это — экран. Большинство bash-команд выводят данные в STDOUT, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда >>
```
```bash
pwd >> myfile
ls –l xfile > myfile
```

# STDERR
```
STDERR представляет собой стандартный поток ошибок оболочки. По умолчанию этот дескриптор указывает на то же самое, на что указывает STDOUT, именно поэтому при возникновении ошибки мы видим сообщение на экране.
```

# Перенаправление потока ошибок
```bash
ls -l xfile 2>myfile
cat ./myfile
```

# Перенаправление потоков ошибок и вывода
```bash
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
```

# Перенаправление вывода в скриптах
```bash

Существует два метода перенаправления вывода в сценариях командной строки:

    Временное перенаправление, или перенаправление вывода одной строки.
    Постоянное перенаправление, или перенаправление всего вывода в скрипте либо в какой-то его части.

```

# Временное перенаправление вывода
```bash
#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
```
```
./myscript 2> myfile
```

# Постоянное перенаправление вывода
```bash
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"
```

```bash
#!/bin/bash
exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
```

# Перенаправление ввода в скриптах
```bash
#!/bin/bash
exec 0< testfile
count=1
while read line; do
    echo "Line #$count: $line"
    count=$(( $count + 1 ))
done
```

# Создание собственного перенаправления вывода
```bash
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
```

# Создание дескрипторов файлов для ввода данных
```bash
#!/bin/bash
exec 6<&0
exec 0< myfile
count=1
while read line; do
    echo "Line #$count: $line"
    count=$(( $count + 1 ))
done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
    y) echo "Goodbye";;
    n) echo "Sorry, this is the end.";;
esac
```

# Закрытие дескрипторов файлов
```bash
#!/bin/bash
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3
```

# Получение сведений об открытых дескрипторах
```bash
Для того, чтобы получить список всех открытых в Linux дескрипторов, можно воспользоваться командой lsof. Во многих дистрибутивах, вроде Fedora, утилита lsof находится в /usr/sbin. Эта команда весьма полезна, так как она выводит сведения о каждом дескрипторе, открытом в системе. Сюда входит и то, что открыли процессы, выполняемые в фоне, и то, что открыто пользователями, вошедшими в систему.

У этой команды есть множество ключей, рассмотрим самые важные.

    -p Позволяет указать ID процесса.
    -d Позволяет указать номер дескриптора, о котором надо получить сведения.


Для того, чтобы узнать PID текущего процесса, можно использовать специальную переменную окружения $$, в которую оболочка записывает текущий PID.
```

```
lsof -a -p $$ -d 0,1,2
```

```bash
#!/bin/bash
exec 3> myfile1
exec 6> myfile2
exec 7< myfile3
lsof -a -p $$ -d 0,1,2,3,6,7
```

# Подавление вывода
```bash
ls -al badfile anotherfile 2> /dev/null
```
```bash
cat /dev/null > myfile
```